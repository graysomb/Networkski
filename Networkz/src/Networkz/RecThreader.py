'''
Created on Jun 10, 2015

@author: graysomb
'''
import time
from multiprocessing import Process
from Networkz import Recorder
import numpy as np
from multiprocessing import JoinableQueue
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from numpy import divide

class RecThreader(object):
    '''
    threads the recorder methods into one
    '''
    


    def __init__(self):
        '''
        Creates the recorder for threading
        '''
        self.rec = Recorder.Recorder()
        
    def playVid(self):
        L = self.vid[1]
        fig = plt.figure()
        ani = animation.ArtistAnimation(fig,L, interval=50, blit=True, repeat_delay=1000)
        plt.show()
        
    def record(self,ti):
        output = JoinableQueue()

        start = time.clock()
        p1 = Process(target = self.rec.recordVid, args = (ti,output,) )
        p2 = Process(target=self.rec.recordKeys,args = (ti,output,))
        p3 = Process(target=self.rec.recordMouse,args = (ti,output,))
        
        p1.start()
        p2.start()
        p3.start()

        output.join()
        time.sleep(1)
        
        self.vid = output.get()
        self.mouseList = output.get()
        self.keyList = output.get()

        
        end = time.clock()
#         self.timeTaken = end-start
        self.timeTaken = self.vid[2]
        print "Recording Finished: "
        print self.timeTaken
        
    def GenerateSamples(self):
        '''
        The matrixes are generated by the following
        keys [w,a,s,d,e,space]
        mouse keys [MLD,MLUp,MRD,MRUp]
        mouse movement [mMT,mMP]
        '''
        print self.keyList
        print self.mouseList
        
        vids = self.vid[0]
        x = len(vids)
        y = len(self.keyList)
        z = len(self.mouseList)-2
        keyMoveList = np.zeros((x,y))
        mouseMoveList = np.zeros((x,z))
        mousePMoveListx = np.zeros((x,1))
        mousePMoveListy = np.zeros((x,1))
        dt = self.timeTaken/len(vids)
        
        
        mMT = self.mouseList[4]
        mMP = self.mouseList[5]
        mMPx=[]
        mMPy=[]
        for i in range (len(mMP)):
            P = mMP[i]
            mMPx.append(P[0])
            mMPy.append(P[1])
        dMPx = []
        dMPy = []
        for j in range(len(mMPx)-1):
            dMPx.append( mMPx[j+1] - mMPx[j])
            dMPy.append( mMPy[j+1] - mMPy[j])

        
        for i in range(len(vids)):
            # generate key list over each frame
            for j in range(len(self.keyList)):
                key = self.keyList[j]
                for k in range(len(key)):
                    if abs(key[k]-dt*i)<=dt/2:
                        keyMoveList[i,j] = 1
            # generate mouse list over each frame
            for j in range(len(self.mouseList)-2):
                mKey = self.mouseList[j]
                for k in range(len(mKey)):
                    if abs(mKey[k]-dt*i)<=dt/2:
                        mouseMoveList[i,j] = 1
            #generate the mouse movement List
            for k in range(len(mMT)-1):
                if abs(mMT[k]-dt*i)<=dt/2:
                    mousePMoveListx[i] += dMPx[k]
                    mousePMoveListy[i] += dMPy[k]
                    
        #need to normalize mousePMoveList

        self.mMinX = np.amin(mousePMoveListx)
        self.mMinY = np.amin(mousePMoveListy)
        
        if self.mMinX <0:
            mousePMoveListx = mousePMoveListx - self.mMinX
        if self.mMinY<0:
            mousePMoveListy = mousePMoveListy - self.mMinY
        
        self.mMaxX = np.amax(mousePMoveListx)
        self.mMaxY = np.amax(mousePMoveListy)
        
        mousePMoveListx = np.true_divide(mousePMoveListx, self.mMaxX)
        mousePMoveListy = np.true_divide(mousePMoveListy, self.mMaxY)
        
        print "Key List :"
        print np.transpose(keyMoveList)
        print "Mouse List :"
        print np.transpose(mouseMoveList)
        print "Mouse Move List :"
        print np.transpose(mousePMoveListx)
        print np.transpose(mousePMoveListy)

        self.WholeList = np.vstack((np.transpose(keyMoveList),np.transpose(mouseMoveList),np.transpose(mousePMoveListx),np.transpose(mousePMoveListy)))
        print "Concatenated List: "
        print self.WholeList
        
    def getIO(self):
        return [ self.WholeList, self.vid]
            
    def saveIO(self):
        np.save('C:\EclipseWorkspaces\pyhtonAI\Networkz\src\Data\Training_Sets\WholeList', self.WholeList)
        np.save('C:\EclipseWorkspaces\pyhtonAI\Networkz\src\Data\Training_Sets\Vid',self.vid)
        
    def loadIO(self):
        self.WholeList = np.load('C:\EclipseWorkspaces\pyhtonAI\Networkz\src\Data\Training_Sets\WholeList.npy')
        self.vid = np.load('C:\EclipseWorkspaces\pyhtonAI\Networkz\src\Data\Training_Sets\Vid.npy')
        print self.WholeList